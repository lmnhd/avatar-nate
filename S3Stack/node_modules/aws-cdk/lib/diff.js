"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.printSecurityDiff = exports.RequireApproval = exports.printStackDiff = void 0;
const util_1 = require("util");
const cxschema = require("@aws-cdk/cloud-assembly-schema");
const cfnDiff = require("@aws-cdk/cloudformation-diff");
const chalk = require("chalk");
const logging_1 = require("./logging");
/**
 * Pretty-prints the differences between two template states to the console.
 *
 * @param oldTemplate the old/current state of the stack.
 * @param newTemplate the new/target state of the stack.
 * @param strict      do not filter out AWS::CDK::Metadata
 * @param context     lines of context to use in arbitrary JSON diff
 * @param quiet       silences \'There were no differences\' messages
 *
 * @returns the number of stacks in this stack tree that have differences, including the top-level root stack
 */
function printStackDiff(oldTemplate, newTemplate, strict, context, quiet, changeSet, stream = process.stderr, nestedStackTemplates) {
    let diff = cfnDiff.fullDiff(oldTemplate, newTemplate.template, changeSet);
    // detect and filter out mangled characters from the diff
    let filteredChangesCount = 0;
    if (diff.differenceCount && !strict) {
        const mangledNewTemplate = JSON.parse(cfnDiff.mangleLikeCloudFormation(JSON.stringify(newTemplate.template)));
        const mangledDiff = cfnDiff.fullDiff(oldTemplate, mangledNewTemplate, changeSet);
        filteredChangesCount = Math.max(0, diff.differenceCount - mangledDiff.differenceCount);
        if (filteredChangesCount > 0) {
            diff = mangledDiff;
        }
    }
    // filter out 'AWS::CDK::Metadata' resources from the template
    if (diff.resources && !strict) {
        diff.resources = diff.resources.filter(change => {
            if (!change) {
                return true;
            }
            if (change.newResourceType === 'AWS::CDK::Metadata') {
                return false;
            }
            if (change.oldResourceType === 'AWS::CDK::Metadata') {
                return false;
            }
            return true;
        });
    }
    let stackDiffCount = 0;
    if (!diff.isEmpty) {
        stackDiffCount++;
        cfnDiff.formatDifferences(stream, diff, {
            ...logicalIdMapFromTemplate(oldTemplate),
            ...buildLogicalToPathMap(newTemplate),
        }, context);
    }
    else if (!quiet) {
        (0, logging_1.print)(chalk.green('There were no differences'));
    }
    if (filteredChangesCount > 0) {
        (0, logging_1.print)(chalk.yellow(`Omitted ${filteredChangesCount} changes because they are likely mangled non-ASCII characters. Use --strict to print them.`));
    }
    for (const nestedStackLogicalId of Object.keys(nestedStackTemplates ?? {})) {
        if (!nestedStackTemplates) {
            break;
        }
        const nestedStack = nestedStackTemplates[nestedStackLogicalId];
        if (!quiet) {
            stream.write((0, util_1.format)('Stack %s\n', chalk.bold(nestedStack.physicalName ?? nestedStackLogicalId)));
        }
        newTemplate._template = nestedStack.generatedTemplate;
        stackDiffCount += printStackDiff(nestedStack.deployedTemplate, newTemplate, strict, context, quiet, undefined, stream, nestedStack.nestedStackTemplates);
    }
    return stackDiffCount;
}
exports.printStackDiff = printStackDiff;
var RequireApproval;
(function (RequireApproval) {
    RequireApproval["Never"] = "never";
    RequireApproval["AnyChange"] = "any-change";
    RequireApproval["Broadening"] = "broadening";
})(RequireApproval || (exports.RequireApproval = RequireApproval = {}));
/**
 * Print the security changes of this diff, if the change is impactful enough according to the approval level
 *
 * Returns true if the changes are prompt-worthy, false otherwise.
 */
function printSecurityDiff(oldTemplate, newTemplate, requireApproval, changeSet) {
    const diff = cfnDiff.fullDiff(oldTemplate, newTemplate.template, changeSet);
    if (difRequiresApproval(diff, requireApproval)) {
        // eslint-disable-next-line max-len
        (0, logging_1.warning)(`This deployment will make potentially sensitive changes according to your current security approval level (--require-approval ${requireApproval}).`);
        (0, logging_1.warning)('Please confirm you intend to make the following modifications:\n');
        cfnDiff.formatSecurityChanges(process.stdout, diff, buildLogicalToPathMap(newTemplate));
        return true;
    }
    return false;
}
exports.printSecurityDiff = printSecurityDiff;
/**
 * Return whether the diff has security-impacting changes that need confirmation
 *
 * TODO: Filter the security impact determination based off of an enum that allows
 * us to pick minimum "severities" to alert on.
 */
function difRequiresApproval(diff, requireApproval) {
    switch (requireApproval) {
        case RequireApproval.Never: return false;
        case RequireApproval.AnyChange: return diff.permissionsAnyChanges;
        case RequireApproval.Broadening: return diff.permissionsBroadened;
        default: throw new Error(`Unrecognized approval level: ${requireApproval}`);
    }
}
function buildLogicalToPathMap(stack) {
    const map = {};
    for (const md of stack.findMetadataByType(cxschema.ArtifactMetadataEntryType.LOGICAL_ID)) {
        map[md.data] = md.path;
    }
    return map;
}
function logicalIdMapFromTemplate(template) {
    const ret = {};
    for (const [logicalId, resource] of Object.entries(template.Resources ?? {})) {
        const path = resource?.Metadata?.['aws:cdk:path'];
        if (path) {
            ret[logicalId] = path;
        }
    }
    return ret;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGlmZi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImRpZmYudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsK0JBQThCO0FBQzlCLDJEQUEyRDtBQUMzRCx3REFBd0Q7QUFHeEQsK0JBQStCO0FBRS9CLHVDQUEyQztBQUUzQzs7Ozs7Ozs7OztHQVVHO0FBQ0gsU0FBZ0IsY0FBYyxDQUM1QixXQUFnQixFQUNoQixXQUE4QyxFQUM5QyxNQUFlLEVBQ2YsT0FBZSxFQUNmLEtBQWMsRUFDZCxTQUFrRCxFQUNsRCxTQUErQixPQUFPLENBQUMsTUFBTSxFQUM3QyxvQkFBK0U7SUFFL0UsSUFBSSxJQUFJLEdBQUcsT0FBTyxDQUFDLFFBQVEsQ0FBQyxXQUFXLEVBQUUsV0FBVyxDQUFDLFFBQVEsRUFBRSxTQUFTLENBQUMsQ0FBQztJQUUxRSx5REFBeUQ7SUFDekQsSUFBSSxvQkFBb0IsR0FBRyxDQUFDLENBQUM7SUFDN0IsSUFBSSxJQUFJLENBQUMsZUFBZSxJQUFJLENBQUMsTUFBTSxFQUFFO1FBQ25DLE1BQU0sa0JBQWtCLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsd0JBQXdCLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxXQUFXLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQzlHLE1BQU0sV0FBVyxHQUFHLE9BQU8sQ0FBQyxRQUFRLENBQUMsV0FBVyxFQUFFLGtCQUFrQixFQUFFLFNBQVMsQ0FBQyxDQUFDO1FBQ2pGLG9CQUFvQixHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxlQUFlLEdBQUcsV0FBVyxDQUFDLGVBQWUsQ0FBQyxDQUFDO1FBQ3ZGLElBQUksb0JBQW9CLEdBQUcsQ0FBQyxFQUFFO1lBQzVCLElBQUksR0FBRyxXQUFXLENBQUM7U0FDcEI7S0FDRjtJQUVELDhEQUE4RDtJQUM5RCxJQUFJLElBQUksQ0FBQyxTQUFTLElBQUksQ0FBQyxNQUFNLEVBQUU7UUFD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SSxFQUFFO1lBQ1IsR0FBRyxDQUFDLFNBQVMsQ0FBQyxHQUFHLElBQUksQ0FBQztTQUN2QjtLQUNGO0lBQ0QsT0FBTyxHQUFHLENBQUM7QUFDYixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZm9ybWF0IH0gZnJvbSAndXRpbCc7XG5pbXBvcnQgKiBhcyBjeHNjaGVtYSBmcm9tICdAYXdzLWNkay9jbG91ZC1hc3NlbWJseS1zY2hlbWEnO1xuaW1wb3J0ICogYXMgY2ZuRGlmZiBmcm9tICdAYXdzLWNkay9jbG91ZGZvcm1hdGlvbi1kaWZmJztcbmltcG9ydCAqIGFzIGN4YXBpIGZyb20gJ0Bhd3MtY2RrL2N4LWFwaSc7XG5pbXBvcnQgeyBDbG91ZEZvcm1hdGlvbiB9IGZyb20gJ2F3cy1zZGsnO1xuaW1wb3J0ICogYXMgY2hhbGsgZnJvbSAnY2hhbGsnO1xuaW1wb3J0IHsgTmVzdGVkU3RhY2tUZW1wbGF0ZXMgfSBmcm9tICcuL2FwaS9uZXN0ZWQtc3RhY2staGVscGVycyc7XG5pbXBvcnQgeyBwcmludCwgd2FybmluZyB9IGZyb20gJy4vbG9nZ2luZyc7XG5cbi8qKlxuICogUHJldHR5LXByaW50cyB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiB0d28gdGVtcGxhdGUgc3RhdGVzIHRvIHRoZSBjb25zb2xlLlxuICpcbiAqIEBwYXJhbSBvbGRUZW1wbGF0ZSB0aGUgb2xkL2N1cnJlbnQgc3RhdGUgb2YgdGhlIHN0YWNrLlxuICogQHBhcmFtIG5ld1RlbXBsYXRlIHRoZSBuZXcvdGFyZ2V0IHN0YXRlIG9mIHRoZSBzdGFjay5cbiAqIEBwYXJhbSBzdHJpY3QgICAgICBkbyBub3QgZmlsdGVyIG91dCBBV1M6OkNESzo6TWV0YWRhdGFcbiAqIEBwYXJhbSBjb250ZXh0ICAgICBsaW5lcyBvZiBjb250ZXh0IHRvIHVzZSBpbiBhcmJpdHJhcnkgSlNPTiBkaWZmXG4gKiBAcGFyYW0gcXVpZXQgICAgICAgc2lsZW5jZXMgXFwnVGhlcmUgd2VyZSBubyBkaWZmZXJlbmNlc1xcJyBtZXNzYWdlc1xuICpcbiAqIEByZXR1cm5zIHRoZSBudW1iZXIgb2Ygc3RhY2tzIGluIHRoaXMgc3RhY2sgdHJlZSB0aGF0IGhhdmUgZGlmZmVyZW5jZXMsIGluY2x1ZGluZyB0aGUgdG9wLWxldmVsIHJvb3Qgc3RhY2tcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByaW50U3RhY2tEaWZmKFxuICBvbGRUZW1wbGF0ZTogYW55LFxuICBuZXdUZW1wbGF0ZTogY3hhcGkuQ2xvdWRGb3JtYXRpb25TdGFja0FydGlmYWN0LFxuICBzdHJpY3Q6IGJvb2xlYW4sXG4gIGNvbnRleHQ6IG51bWJlcixcbiAgcXVpZXQ6IGJvb2xlYW4sXG4gIGNoYW5nZVNldD86IENsb3VkRm9ybWF0aW9uLkRlc2NyaWJlQ2hhbmdlU2V0T3V0cHV0LFxuICBzdHJlYW06IGNmbkRpZmYuRm9ybWF0U3RyZWFtID0gcHJvY2Vzcy5zdGRlcnIsXG4gIG5lc3RlZFN0YWNrVGVtcGxhdGVzPzogeyBbbmVzdGVkU3RhY2tMb2dpY2FsSWQ6IHN0cmluZ106IE5lc3RlZFN0YWNrVGVtcGxhdGVzIH0pOiBudW1iZXIge1xuXG4gIGxldCBkaWZmID0gY2ZuRGlmZi5mdWxsRGlmZihvbGRUZW1wbGF0ZSwgbmV3VGVtcGxhdGUudGVtcGxhdGUsIGNoYW5nZVNldCk7XG5cbiAgLy8gZGV0ZWN0IGFuZCBmaWx0ZXIgb3V0IG1hbmdsZWQgY2hhcmFjdGVycyBmcm9tIHRoZSBkaWZmXG4gIGxldCBmaWx0ZXJlZENoYW5nZXNDb3VudCA9IDA7XG4gIGlmIChkaWZmLmRpZmZlcmVuY2VDb3VudCAmJiAhc3RyaWN0KSB7XG4gICAgY29uc3QgbWFuZ2xlZE5ld1RlbXBsYXRlID0gSlNPTi5wYXJzZShjZm5EaWZmLm1hbmdsZUxpa2VDbG91ZEZvcm1hdGlvbihKU09OLnN0cmluZ2lmeShuZXdUZW1wbGF0ZS50ZW1wbGF0ZSkpKTtcbiAgICBjb25zdCBtYW5nbGVkRGlmZiA9IGNmbkRpZmYuZnVsbERpZmYob2xkVGVtcGxhdGUsIG1hbmdsZWROZXdUZW1wbGF0ZSwgY2hhbmdlU2V0KTtcbiAgICBmaWx0ZXJlZENoYW5nZXNDb3VudCA9IE1hdGgubWF4KDAsIGRpZmYuZGlmZmVyZW5jZUNvdW50IC0gbWFuZ2xlZERpZmYuZGlmZmVyZW5jZUNvdW50KTtcbiAgICBpZiAoZmlsdGVyZWRDaGFuZ2VzQ291bnQgPiAwKSB7XG4gICAgICBkaWZmID0gbWFuZ2xlZERpZmY7XG4gICAgfVxuICB9XG5cbiAgLy8gZmlsdGVyIG91dCAnQVdTOjpDREs6Ok1ldGFkYXRhJyByZXNvdXJjZXMgZnJvbSB0aGUgdGVtcGxhdGVcbiAgaWYgKGRpZmYucmVzb3VyY2VzICYmICFzdHJpY3QpIHtcbiAgICBkaWZmLnJlc291cmNlcyA9IGRpZmYucmVzb3VyY2VzLmZpbHRlcihjaGFuZ2UgPT4ge1xuICAgICAgaWYgKCFjaGFuZ2UpIHsgcmV0dXJuIHRydWU7IH1cbiAgICAgIGlmIChjaGFuZ2UubmV3UmVzb3VyY2VUeXBlID09PSAnQVdTOjpDREs6Ok1ldGFkYXRhJykgeyByZXR1cm4gZmFsc2U7IH1cbiAgICAgIGlmIChjaGFuZ2Uub2xkUmVzb3VyY2VUeXBlID09PSAnQVdTOjpDREs6Ok1ldGFkYXRhJykgeyByZXR1cm4gZmFsc2U7IH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuICB9XG5cbiAgbGV0IHN0YWNrRGlmZkNvdW50ID0gMDtcbiAgaWYgKCFkaWZmLmlzRW1wdHkpIHtcbiAgICBzdGFja0RpZmZDb3VudCsrO1xuICAgIGNmbkRpZmYuZm9ybWF0RGlmZmVyZW5jZXMoc3RyZWFtLCBkaWZmLCB7XG4gICAgICAuLi5sb2dpY2FsSWRNYXBGcm9tVGVtcGxhdGUob2xkVGVtcGxhdGUpLFxuICAgICAgLi4uYnVpbGRMb2dpY2FsVG9QYXRoTWFwKG5ld1RlbXBsYXRlKSxcbiAgICB9LCBjb250ZXh0KTtcbiAgfSBlbHNlIGlmICghcXVpZXQpIHtcbiAgICBwcmludChjaGFsay5ncmVlbignVGhlcmUgd2VyZSBubyBkaWZmZXJlbmNlcycpKTtcbiAgfVxuICBpZiAoZmlsdGVyZWRDaGFuZ2VzQ291bnQgPiAwKSB7XG4gICAgcHJpbnQoY2hhbGsueWVsbG93KGBPbWl0dGVkICR7ZmlsdGVyZWRDaGFuZ2VzQ291bnR9IGNoYW5nZXMgYmVjYXVzZSB0aGV5IGFyZSBsaWtlbHkgbWFuZ2xlZCBub24tQVNDSUkgY2hhcmFjdGVycy4gVXNlIC0tc3RyaWN0IHRvIHByaW50IHRoZW0uYCkpO1xuICB9XG5cbiAgZm9yIChjb25zdCBuZXN0ZWRTdGFja0xvZ2ljYWxJZCBvZiBPYmplY3Qua2V5cyhuZXN0ZWRTdGFja1RlbXBsYXRlcyA/PyB7fSkpIHtcbiAgICBpZiAoIW5lc3RlZFN0YWNrVGVtcGxhdGVzKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY29uc3QgbmVzdGVkU3RhY2sgPSBuZXN0ZWRTdGFja1RlbXBsYXRlc1tuZXN0ZWRTdGFja0xvZ2ljYWxJZF07XG4gICAgaWYgKCFxdWlldCkge1xuICAgICAgc3RyZWFtLndyaXRlKGZvcm1hdCgnU3RhY2sgJXNcXG4nLCBjaGFsay5ib2xkKG5lc3RlZFN0YWNrLnBoeXNpY2FsTmFtZSA/PyBuZXN0ZWRTdGFja0xvZ2ljYWxJZCkpKTtcbiAgICB9XG5cbiAgICAobmV3VGVtcGxhdGUgYXMgYW55KS5fdGVtcGxhdGUgPSBuZXN0ZWRTdGFjay5nZW5lcmF0ZWRUZW1wbGF0ZTtcbiAgICBzdGFja0RpZmZDb3VudCArPSBwcmludFN0YWNrRGlmZihcbiAgICAgIG5lc3RlZFN0YWNrLmRlcGxveWVkVGVtcGxhdGUsXG4gICAgICBuZXdUZW1wbGF0ZSxcbiAgICAgIHN0cmljdCxcbiAgICAgIGNvbnRleHQsXG4gICAgICBxdWlldCxcbiAgICAgIHVuZGVmaW5lZCxcbiAgICAgIHN0cmVhbSxcbiAgICAgIG5lc3RlZFN0YWNrLm5lc3RlZFN0YWNrVGVtcGxhdGVzLFxuICAgICk7XG4gIH1cblxuICByZXR1cm4gc3RhY2tEaWZmQ291bnQ7XG59XG5cbmV4cG9ydCBlbnVtIFJlcXVpcmVBcHByb3ZhbCB7XG4gIE5ldmVyID0gJ25ldmVyJyxcblxuICBBbnlDaGFuZ2UgPSAnYW55LWNoYW5nZScsXG5cbiAgQnJvYWRlbmluZyA9ICdicm9hZGVuaW5nJyxcbn1cblxuLyoqXG4gKiBQcmludCB0aGUgc2VjdXJpdHkgY2hhbmdlcyBvZiB0aGlzIGRpZmYsIGlmIHRoZSBjaGFuZ2UgaXMgaW1wYWN0ZnVsIGVub3VnaCBhY2NvcmRpbmcgdG8gdGhlIGFwcHJvdmFsIGxldmVsXG4gKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBjaGFuZ2VzIGFyZSBwcm9tcHQtd29ydGh5LCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcmludFNlY3VyaXR5RGlmZihcbiAgb2xkVGVtcGxhdGU6IGFueSxcbiAgbmV3VGVtcGxhdGU6IGN4YXBpLkNsb3VkRm9ybWF0aW9uU3RhY2tBcnRpZmFjdCxcbiAgcmVxdWlyZUFwcHJvdmFsOiBSZXF1aXJlQXBwcm92YWwsXG4gIGNoYW5nZVNldD86IENsb3VkRm9ybWF0aW9uLkRlc2NyaWJlQ2hhbmdlU2V0T3V0cHV0LFxuKTogYm9vbGVhbiB7XG4gIGNvbnN0IGRpZmYgPSBjZm5EaWZmLmZ1bGxEaWZmKG9sZFRlbXBsYXRlLCBuZXdUZW1wbGF0ZS50ZW1wbGF0ZSwgY2hhbmdlU2V0KTtcblxuICBpZiAoZGlmUmVxdWlyZXNBcHByb3ZhbChkaWZmLCByZXF1aXJlQXBwcm92YWwpKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1sZW5cbiAgICB3YXJuaW5nKGBUaGlzIGRlcGxveW1lbnQgd2lsbCBtYWtlIHBvdGVudGlhbGx5IHNlbnNpdGl2ZSBjaGFuZ2VzIGFjY29yZGluZyB0byB5b3VyIGN1cnJlbnQgc2VjdXJpdHkgYXBwcm92YWwgbGV2ZWwgKC0tcmVxdWlyZS1hcHByb3ZhbCAke3JlcXVpcmVBcHByb3ZhbH0pLmApO1xuICAgIHdhcm5pbmcoJ1BsZWFzZSBjb25maXJtIHlvdSBpbnRlbmQgdG8gbWFrZSB0aGUgZm9sbG93aW5nIG1vZGlmaWNhdGlvbnM6XFxuJyk7XG5cbiAgICBjZm5EaWZmLmZvcm1hdFNlY3VyaXR5Q2hhbmdlcyhwcm9jZXNzLnN0ZG91dCwgZGlmZiwgYnVpbGRMb2dpY2FsVG9QYXRoTWFwKG5ld1RlbXBsYXRlKSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFJldHVybiB3aGV0aGVyIHRoZSBkaWZmIGhhcyBzZWN1cml0eS1pbXBhY3RpbmcgY2hhbmdlcyB0aGF0IG5lZWQgY29uZmlybWF0aW9uXG4gKlxuICogVE9ETzogRmlsdGVyIHRoZSBzZWN1cml0eSBpbXBhY3QgZGV0ZXJtaW5hdGlvbiBiYXNlZCBvZmYgb2YgYW4gZW51bSB0aGF0IGFsbG93c1xuICogdXMgdG8gcGljayBtaW5pbXVtIFwic2V2ZXJpdGllc1wiIHRvIGFsZXJ0IG9uLlxuICovXG5mdW5jdGlvbiBkaWZSZXF1aXJlc0FwcHJvdmFsKGRpZmY6IGNmbkRpZmYuVGVtcGxhdGVEaWZmLCByZXF1aXJlQXBwcm92YWw6IFJlcXVpcmVBcHByb3ZhbCkge1xuICBzd2l0Y2ggKHJlcXVpcmVBcHByb3ZhbCkge1xuICAgIGNhc2UgUmVxdWlyZUFwcHJvdmFsLk5ldmVyOiByZXR1cm4gZmFsc2U7XG4gICAgY2FzZSBSZXF1aXJlQXBwcm92YWwuQW55Q2hhbmdlOiByZXR1cm4gZGlmZi5wZXJtaXNzaW9uc0FueUNoYW5nZXM7XG4gICAgY2FzZSBSZXF1aXJlQXBwcm92YWwuQnJvYWRlbmluZzogcmV0dXJuIGRpZmYucGVybWlzc2lvbnNCcm9hZGVuZWQ7XG4gICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKGBVbnJlY29nbml6ZWQgYXBwcm92YWwgbGV2ZWw6ICR7cmVxdWlyZUFwcHJvdmFsfWApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGJ1aWxkTG9naWNhbFRvUGF0aE1hcChzdGFjazogY3hhcGkuQ2xvdWRGb3JtYXRpb25TdGFja0FydGlmYWN0KSB7XG4gIGNvbnN0IG1hcDogeyBbaWQ6IHN0cmluZ106IHN0cmluZyB9ID0ge307XG4gIGZvciAoY29uc3QgbWQgb2Ygc3RhY2suZmluZE1ldGFkYXRhQnlUeXBlKGN4c2NoZW1hLkFydGlmYWN0TWV0YWRhdGFFbnRyeVR5cGUuTE9HSUNBTF9JRCkpIHtcbiAgICBtYXBbbWQuZGF0YSBhcyBzdHJpbmddID0gbWQucGF0aDtcbiAgfVxuICByZXR1cm4gbWFwO1xufVxuXG5mdW5jdGlvbiBsb2dpY2FsSWRNYXBGcm9tVGVtcGxhdGUodGVtcGxhdGU6IGFueSkge1xuICBjb25zdCByZXQ6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7fTtcblxuICBmb3IgKGNvbnN0IFtsb2dpY2FsSWQsIHJlc291cmNlXSBvZiBPYmplY3QuZW50cmllcyh0ZW1wbGF0ZS5SZXNvdXJjZXMgPz8ge30pKSB7XG4gICAgY29uc3QgcGF0aCA9IChyZXNvdXJjZSBhcyBhbnkpPy5NZXRhZGF0YT8uWydhd3M6Y2RrOnBhdGgnXTtcbiAgICBpZiAocGF0aCkge1xuICAgICAgcmV0W2xvZ2ljYWxJZF0gPSBwYXRoO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmV0O1xufVxuIl19